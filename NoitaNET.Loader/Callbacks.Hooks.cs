using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text.RegularExpressions;
using NoitaNET.API.Hooks;
using NoitaNET.API.Logging;
using NoitaNET.Loader.Symbols;

namespace NoitaNET.Loader;

internal unsafe partial class Callbacks
{
    /// How does this all work?
    /// The MessageHookGenerator generates a hook into all neccessart MessageListener<>::HandleMessage functions
    /// We then wait for it to be called
    /// Once MessageListener<>::HandleMessage has been called, we are able to steal the vftable from it
    /// At an offset of 8 from the start of the vftable is the function that is called to cache and execute arbitrary lua scripts for Components that define these
    /// We are now able to hook this third vftable function, and do so immediately
    /// That is what calls LuaComponent_HandleMessage_Message_Shot
    /// The provided path to this script is present inside of this function that is supposed to execute the script
    /// I plan to use this path to determine which is a NoitaNET function

    /// <summary>
    /// Pattern that matches all MessageListener<>::HandleMessage functions
    /// </summary>
    private static readonly string HandleMessagePattern = "55 8b ec 6a ff 68 ?? ?? ?? ?? 64 a1 ?? ?? ?? ?? 50 83 ec 0c 53 56 57 a1 ?? ?? ?? ?? 33 c5 50 8d ?? f4 64 a3 ?? ?? ?? ?? 8b f9 6a 00 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? 6a 00 57 e8 ?? ?? ?? ?? 8b c8 83 c4 14 85 c9 75 ?? 68 ?? ?? ?? ?? 68 ?? ?? ?? ?? b9 ?? ?? ?? ?? e8 ?? ?? ?? ?? 8b c8 e8 ?? ?? ?? ?? 8b ?? ?? 64 89 0d ?? ?? ?? ?? 59 5f 5e 5b 8b e5 5d c2 08 00";

    /// <summary>
    /// std::string definition in msvc120
    /// </summary>
    private struct basic_string
    {
        private nint DataPointer = 0;
        private fixed byte SsoBuffer[12];
        public nint Capacity = 0;
        public nint Size = 0;

        public nint Data => IsSSO ? (nint)Unsafe.AsPointer(ref DataPointer) : DataPointer;

        private readonly bool IsSSO => Capacity < 0x10;

        public basic_string()
        {

        }
    }

    [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvThiscall) })]
    private static void LuaComponent_HandleMessage_Message_Shot(nint pThis, nint param_1, nint param_2, nint param_3)
    {
        nint yeah = param_2 + 0x37 * sizeof(nint);

        basic_string* mhm = (basic_string*)yeah;

        if (mhm != null && mhm->Size > 0)
        {
            Logger.Instance.LogDebug($"PATH??: {Marshal.PtrToStringUTF8(mhm->Data)}");
        }

        OLuaComponent_HandleMessage_Message_Shot(pThis, param_1, param_2, param_3);
    }

    static Callbacks()
    {
        List<nint> handleMessageFunctions = PatternScanner.ScanMulitple(Process.GetCurrentProcess().MainModule!, HandleMessagePattern);

        foreach (nint address in handleMessageFunctions)
        {
            // 50 bytes after the start of every MessageListener<>::HandleMessage function, theres a push RTTI_Type_Descriptor
            // This reads the address of the RTTI_Type_Descriptor
            nint typeDescAddress = Unsafe.Read<nint>((void*)(address + 50));

            string demangledSymbol = Demangler.GetSymbolNameFromRTTI(typeDescAddress);

            (string component, string messageType) = GetMessageInformation(demangledSymbol);

            // Find the functions and delegate for original function that was generated by source generator
            string function = $"{component}_HandleMessage_{messageType}";
            
            MethodInfo? method = typeof(Callbacks).GetMethod($"__H_{function}", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
            FieldInfo? originalMessageHandlerField = typeof(Callbacks).GetField($"__O_{function}", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);

            if (method is not null)
            {
                NativeHook nativeHook = new NativeHook(address, method.MethodHandle.GetFunctionPointer());

                originalMessageHandlerField?.SetValue(null, Marshal.GetDelegateForFunctionPointer<__D_MessageHandler>(nativeHook.Original));
            }
        }
    }

    private static (string, string) GetMessageInformation(string symbol)
    {
        Match match = Regex.Match(symbol, @"MessageListener<class ([^,]+),class ([^,]+),\d+>");

        if (match.Success && match.Groups.Count == 3)
        {
            return (match.Groups[1].Value, match.Groups[2].Value);
        }

        throw new Exception($"Invalid MessageListener symbol '{symbol}'");
    }
}